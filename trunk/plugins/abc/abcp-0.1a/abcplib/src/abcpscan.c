/* Generated by re2c 0.5 on Fri Dec 31 13:56:15 2004 */
#line 1 "abcpscan.re"
/*
 .T ABCp A generic ABC Parser
 .A ...
 .d Aug 2004

 .abstract
   This is the '/scanner/ used in ABCp. The main function
   is '{abcNextToken()} that returns the next token in a file
   based on the current state.
 ..

 .disclaimer
   This code is distributed under an OSI compliant licence 
   The short story is that you are free to use this code as you wish
   as long as the appropriate credit to authors is given in a convenient
   place in your application and in the associated documentation.
   
   ABCp uses '|re2C|. See '<http://re2c.sourceforge.net> for details.
 ..
 
 .* How to read this file
 
 You should start from the abcNextFunction.
 
*/

#define GLOBAL

#include "abcp.h"

/* Just checked, it does not harm the UTF-8 compliancy */
#define SOL '\001'
#define EOL '\002'

void abcClose(abcScanner *s);
abcScanner *abcOpen(char *filename,USHORT bufsize);
int abcNextToken(abcScanner *s);

#ifdef DLL

BOOL WINAPI __declspec(dllexport) LibMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            break;
            
        case DLL_PROCESS_DETACH:
            break;
            
        case DLL_THREAD_ATTACH:
            break;
            
        case DLL_THREAD_DETACH:
            break;
    }
    return TRUE;
}

#endif

static char *abcTokName[]={
  "T_FIRST",
  "T_UNKNOWN",   "T_NONE",         "T_EOF",       "T_COMMENT",   "T_EMPTYLINE",
  "T_EXTFIELD",  "T_FIELD",        "T_NOTE",      "T_WSPACE",    "T_BAR",
  "T_INFIELD",   "T_TEXT",         "T_ENDLINE",   "T_CONTINUE",  "T_DECOR",
  "T_REST",      "T_INVREST",      "T_MULTIREST", "T_SPACER",    "T_NPLET",
  "T_OPENSLUR",  "T_CLOSESLUR",    "T_DOTRIGHT",  "T_DOTLEFT",   "T_CHORDSTART",
  "T_CHORDEND",  "T_CHORD",        "T_REPEAT",    "T_GRACEAPP",  "T_GRACEACC",
  "T_GRACEEND",  "T_TIE",          "T_STRING",    "T_STRINGUNF", "T_ANNOTATION",
  "T_BREAK",     "T_OVERLAY",      "T_STARTLINE", "T_FIELDB",    "T_PRAGMA",
  "T_LYR_SYLL",  "T_LYR_BLANK",    "T_LYR_BAR",   "T_LYR_SPACE", "T_LYR_CONT",
  "T_LYR_VERSE", "T_OPENSLUR_DOT", "T_TIE_DOT",   "T_DUPMESURE", "T_DECOR_BLANK",
  "T_BSPACE",
  "T_LAST"
};

static char *abcStName[]={
/*  0 */ "S_EOF", 
/*  1 */ "S_ERROR",
/*  2 */ "S_LIMBO",
/*  3 */ "S_NONE",
/*  4 */ "S_TUNE",
/*  5 */ "S_FIELD",
/*  6 */ "S_EXTFIELD",
/*  7 */ "S_INFIELD"
};

/*
** Buffer limit
*/

#define MINBUFSIZE     1024
#define MAXBUFSIZE  5242880 



/*
 .* Macros
*/

/* To ease my paranoia about dynamic memory allocation
*/
#define m_guard(x)      (x)->guard=0xF00D
#define m_unguard(x)    (x)->guard=0x0BAD
#define m_guarded(x)    ((x) && ((x)->guard == 0xF00D))

/*                       if (*(x)->cursor == '\001') (x)->cursor++;\ */
 
/*
When a Match is found, the RETURN macro performs the following actions:

 1) The token field is set to the token 
 2) The "start of line char" ('\001') is skipped
 3) The length of token is computed
 4) The tokstr field is initialized to point to the start of the
    string that matched.
 5) The cursor is advanced right after the matched string
 6) The newline character, if present, is deleted
 7) The marker is set
 8) The first character of the next string to match is saved
    in the last char of the buffer.
 9) The first character of the next string is replaced by '\0' so
    that s->tokstr is a properly null terminated string.
    The saved char is to be restored next time the abcNextToken()
    is called.
10) The length of the string matched is returned.
    
*/


#define RETURN(x,t)   {(x)->token=t;\
                      if (*((x)->cursor) == SOL) (x)->cursor = (x)->cursor +1;\
                      (x)->toklen = YYCURSOR - (x)->cursor;\
                      (x)->tokstr = (x)->cursor;\
                      (x)->cursor = YYCURSOR;\
                      (x)->lastch = *YYCURSOR;\
                      if (*((x)->cursor - 1) == '\n') *((x)->cursor - 1) = '\0';\
                      (x)->marker = marker;\
                      *((x)->cursor) = '\0';\
                      (x)->pack[0]='\0';\
                      return (x)->toklen;}

#define m_linestart(x)  ((x)->cursor == (x)->buffer)
#define m_lineempty(x)  (*((x)->cursor) == '\0')
#define m_resetbuf(x)   {(x)->buffer[0]='\0';  \
                         (x)->buffer[1]='\0';  \
                         (x)->limit=(x)->buffer; \
                         (x)->cursor=(x)->limit; \
                         (x)->marker=(x)->cursor; \
                         (x)->tokstr=(x)->limit; \
                         (x)->lastch ='\0'; \
                         (x)->toklen=0;}

#define m_eof(x)  {m_resetbuf(x); \
                   (x)->token=T_EOF;\
                   (x)->state=S_EOF;}

#define m_column(x) ((x)->tokstr - (x)->buffer)

/*
** The scanning routines
**   If we are parsing a string, s->nextln points at the beginning
** of next line.
**
**   To correctly handle logical continuations, the buffer might
** be filled with more than 1 line. A '\n' will indicate a continuation.

** WARNING: this scanner does not support comments after continued lines! 

*/

static void abcGetLine(abcScanner *s)
{
  YYCTYPE *t=NULL;
  YYCTYPE *b=NULL;
  int max=s->bufsize;
  int cont=1;
  
  if (m_guarded(s) && (s->state != S_EOF)) {
    m_resetbuf(s);
    s->buffer[0] = SOL;
    b=s->buffer+1;
    if (s->file) {
      do {
        t=fgets(b,max,s->file);
        cont=0;
        if (t) {
          while (*t) t++;
          while ((t>b) && isspace(t[-1])) t--;
          if (t[-1]=='\\') {
            s->line++;
            t[-1]='\n';
            cont=1;
          }
          *t='\0';
          max -= t-b;
          b=t;
        }
      } while (t && cont);
      *b++=EOL; *b='\0';
      /*printf("*\t[%s]\n",s->buffer);*/

    }
    else if (s->nextln && *(s->nextln))  {
      /*printf("+%s\n",s->nextln);*/
      t=s->buffer+1;
      do {
        cont =0 ;
        while (*(s->nextln) && (*(s->nextln) != '\n'))
          *t++ = *(s->nextln)++;
        *t++ = *(s->nextln)++;
        /*if (*(s->nextln) != '\0') (s->nextln)++;*/
        while ((t > (s->buffer +1)) && isspace(t[-1]))
            t--;
        if (t[-1]=='\\') {
          s->line++;
          t[-1]='\n';
          cont=1;
        }
      } while (cont && *(s->nextln));
      *t++=EOL; *t='\0';
    }
    if (t) {
      s->line++;
      s->cursor=s->buffer;
      t=s->buffer; while (*t) t++;
      s->limit=t;
      s->marker=s->cursor;
    }
    else
      m_eof(s);
  }
}

#define P(x,y) abcN##x(y->pack,(char *)abcString(y))

static void abcNparse(abcScanner *s)
{
  int t; 
  int a;
  
  t=abcToken(s);

  switch (t) {
    case T_REST:
    case T_NOTE:     P(Note,s);          break;
    case T_DECOR:    P(Decoration,s);    break;
    case T_TIE:    
    case T_OPENSLUR: P(SlurTie,s);       break;
    case T_BAR: P(Bar,s); break;
    case T_FIELDB:
      a=abcState(s);
      if (a & S_CFIELD) {
        switch (a & 0xFF ) {
          case 'K' : P(Key,s);    break;
          case 'V' : P(Voice,s);  break;
          case 'M' : P(Meter,s);  break;
          case 'L' : P(Length,s); break;
          case 'Q' : P(Tempo,s);  break;

          case 'A' :
          case 'O' :
          case 'C' :
          case 'D' :
          case 'Z' : P(list,s);   break;

          default:   P(string,s); break;
        }              
      }
      break;
    default: s->pack[0]='?';s->pack[1]='\0'; 
  }
}

#line 311


static int abcNT(abcScanner *s)
{
  YYCTYPE *cursor, *limit, *marker;
  cursor = s->cursor;
  limit  = s->limit;
  marker = s->marker;
  
  {
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy0;
yy1:	++YYCURSOR;
yy0:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych <= '\037'){
		if(yych <= '\002'){
			if(yych <= '\000')	goto yy2;
			if(yych <= '\001')	goto yy4;
			goto yy13;
		} else {
			if(yych == '\t')	goto yy7;
			goto yy17;
		}
	} else {
		if(yych <= '#'){
			if(yych <= ' ')	goto yy7;
			if(yych <= '"')	goto yy17;
			goto yy11;
		} else {
			if(yych <= '$')	goto yy17;
			if(yych <= '%')	goto yy9;
			if(yych <= '&')	goto yy15;
			goto yy17;
		}
	}
yy2:	yych = *++YYCURSOR;
	goto yy3;
yy3:
#line 322
	{ return -1;}
yy4:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy5;
yy5:	if(yych <= ' '){
		if(yych <= '\b'){
			if(yych == '\002')	goto yy22;
			goto yy6;
		} else {
			if(yych <= '\t')	goto yy4;
			if(yych >= ' ')	goto yy4;
			goto yy6;
		}
	} else {
		if(yych <= '@'){
			if(yych == '%')	goto yy25;
			goto yy6;
		} else {
			if(yych <= 'Z')	goto yy24;
			if(yych <= '`')	goto yy6;
			if(yych <= 'z')	goto yy24;
			goto yy6;
		}
	}
yy6:	YYCURSOR = YYMARKER;
	switch(yyaccept){
	case 0:	goto yy8;
	}
yy7:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '\037'){
		if(yych <= '\002'){
			if(yych >= '\002')	goto yy13;
			goto yy8;
		} else {
			if(yych == '\t')	goto yy18;
			goto yy8;
		}
	} else {
		if(yych <= '#'){
			if(yych <= ' ')	goto yy18;
			if(yych >= '#')	goto yy20;
			goto yy8;
		} else {
			if(yych == '%')	goto yy21;
			goto yy8;
		}
	}
yy8:
#line 363
	{ return -1;}
yy9:	yych = *++YYCURSOR;
	goto yy10;
yy10:
#line 336
	{
      s->cursor=YYCURSOR;
      YYCURSOR=YYLIMIT-1;
      RETURN(s,T_COMMENT);
  }
yy11:	yych = *++YYCURSOR;
	goto yy12;
yy12:
#line 342
	{
      s->cursor=YYCURSOR;
      YYCURSOR=YYLIMIT-1;
      RETURN(s,T_PRAGMA);
  }
yy13:	yych = *++YYCURSOR;
	goto yy14;
yy14:
#line 355
	{
      if (s->state & S_ANYFIELD) s->nextstate=S_TUNE;
      YYCURSOR[-1]='\0';
      RETURN(s,T_ENDLINE);
  }
yy15:	yych = *++YYCURSOR;
	goto yy16;
yy16:
#line 361
	{ RETURN(s,T_OVERLAY); }
yy17:	yych = *++YYCURSOR;
	goto yy8;
yy18:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy19;
yy19:	if(yych <= '\037'){
		if(yych <= '\002'){
			if(yych <= '\001')	goto yy6;
			goto yy13;
		} else {
			if(yych == '\t')	goto yy18;
			goto yy6;
		}
	} else {
		if(yych <= '#'){
			if(yych <= ' ')	goto yy18;
			if(yych <= '"')	goto yy6;
			goto yy20;
		} else {
			if(yych == '%')	goto yy21;
			goto yy6;
		}
	}
yy20:	yych = *++YYCURSOR;
	goto yy12;
yy21:	yych = *++YYCURSOR;
	goto yy10;
yy22:	yych = *++YYCURSOR;
	goto yy23;
yy23:
#line 348
	{
      s->cursor++;
      s->nextstate=S_LIMBO;
      YYCURSOR=YYLIMIT-1;
      RETURN(s,T_EMPTYLINE);
  }
yy24:	yych = *++YYCURSOR;
	if(yych == ':')	goto yy29;
	goto yy6;
yy25:	yych = *++YYCURSOR;
	if(yych != '%')	goto yy6;
	goto yy26;
yy26:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy27;
yy27:	if(yych == '\t')	goto yy26;
	if(yych == ' ')	goto yy26;
	goto yy28;
yy28:
#line 324
	{
      s->nextstate=S_EXTFIELD | (getextfield(&YYCURSOR) & 0x0FFF);
      s->cursor=YYCURSOR;
      RETURN(s,T_EXTFIELD);
  }
yy29:	yych = *++YYCURSOR;
	goto yy30;
yy30:
#line 330
	{
      s->cursor=YYCURSOR-2;
      s->nextstate =  S_FIELD | *(s->cursor);
      RETURN(s,T_FIELD);
  }
}
#line 365

}

static int abcNT_FIELD_H(abcScanner *s)
{
  YYCTYPE *cursor, *limit, *marker;
  
  cursor = s->cursor;
  limit  = s->limit;
  marker = s->marker;
  
  {
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy31;
yy32:	++YYCURSOR;
yy31:
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= '\000')	goto yy36;
	if(yych <= '\001')	goto yy33;
	if(yych <= '\002')	goto yy38;
	goto yy40;
yy33:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy34;
yy34:	if(yych <= ' '){
		if(yych <= '\b'){
			if(yych == '\002')	goto yy42;
			goto yy35;
		} else {
			if(yych <= '\t')	goto yy33;
			if(yych >= ' ')	goto yy33;
			goto yy35;
		}
	} else {
		if(yych <= '@'){
			if(yych == '%')	goto yy44;
			goto yy35;
		} else {
			if(yych <= 'Z')	goto yy45;
			if(yych <= '`')	goto yy35;
			if(yych <= 'z')	goto yy45;
			goto yy35;
		}
	}
yy35:yy36:	yych = *++YYCURSOR;
	goto yy37;
yy37:
#line 381
	{ return -1; }
yy38:	yych = *++YYCURSOR;
	goto yy39;
yy39:
#line 382
	{ YYCURSOR[-1]='\0';
                  YYCURSOR=YYLIMIT;
                  RETURN(s,T_ENDLINE);
                }
yy40:	yych = *++YYCURSOR;
	goto yy41;
yy41:
#line 386
	{ YYCURSOR=YYLIMIT-1;
                  RETURN(s,T_FIELDB);
                }
yy42:	yych = *++YYCURSOR;
	goto yy43;
yy43:
#line 380
	{ return -1; }
yy44:	yych = *++YYCURSOR;
	if(yych == '%')	goto yy48;
	goto yy35;
yy45:	yych = *++YYCURSOR;
	if(yych != ':')	goto yy35;
	goto yy46;
yy46:	yych = *++YYCURSOR;
	goto yy47;
yy47:
#line 378
	{ return -1; }
yy48:	yych = *++YYCURSOR;
	goto yy49;
yy49:
#line 379
	{ return -1; }
}
#line 390


  
}

static int abcNT_FIELD_w(abcScanner *s)
{
  YYCTYPE *cursor, *limit, *marker;
  
  cursor = s->cursor;
  limit  = s->limit;
  marker = s->marker;

note:    
  {
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy50;
yy51:	++YYCURSOR;
yy50:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych <= '-'){
		if(yych <= '\r'){
			if(yych <= '\b'){
				if(yych <= '\000')	goto yy52;
				if(yych <= '\001')	goto yy53;
				if(yych <= '\002')	goto yy73;
				goto yy75;
			} else {
				if(yych <= '\t')	goto yy55;
				if(yych <= '\n')	goto yy71;
				if(yych <= '\f')	goto yy75;
				goto yy71;
			}
		} else {
			if(yych <= '&'){
				if(yych <= '\037')	goto yy75;
				if(yych <= ' ')	goto yy55;
				if(yych <= '!')	goto yy57;
				goto yy75;
			} else {
				if(yych <= '*'){
					if(yych <= ')')	goto yy57;
					goto yy61;
				} else {
					if(yych <= '+')	goto yy75;
					if(yych <= ',')	goto yy57;
					goto yy63;
				}
			}
		}
	} else {
		if(yych <= ']'){
			if(yych <= '@'){
				if(yych <= '.')	goto yy57;
				if(yych == '?')	goto yy57;
				goto yy75;
			} else {
				if(yych <= 'Z')	goto yy57;
				if(yych <= '[')	goto yy75;
				if(yych <= '\\')	goto yy59;
				goto yy69;
			}
		} else {
			if(yych <= 'z'){
				if(yych == '_')	goto yy65;
				if(yych <= '`')	goto yy75;
				goto yy57;
			} else {
				if(yych <= '|'){
					if(yych <= '{')	goto yy75;
					goto yy67;
				} else {
					if(yych == '~')	goto yy57;
					goto yy75;
				}
			}
		}
	}
yy52:	YYCURSOR = YYMARKER;
	switch(yyaccept){
	case 0:	goto yy58;
	}
yy53:	yych = *++YYCURSOR;
	goto yy54;
yy54:
#line 405
	{ s->cursor++; goto note; }
yy55:	yych = *++YYCURSOR;
	goto yy83;
yy56:
#line 407
	{ RETURN(s,T_LYR_SPACE); }
yy57:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	goto yy79;
yy58:
#line 410
	{ RETURN(s,T_LYR_SYLL); }
yy59:	yych = *++YYCURSOR;
	if(yych <= ' ')	goto yy60;
	if(yych <= '\177')	goto yy78;
	goto yy60;
yy60:
#line 431
	{ RETURN(s,T_LYR_SYLL); }
yy61:	yych = *++YYCURSOR;
	goto yy62;
yy62:
#line 412
	{ RETURN(s,T_LYR_BLANK); }
yy63:	yych = *++YYCURSOR;
	goto yy64;
yy64:
#line 414
	{ RETURN(s,T_LYR_SYLL); }
yy65:	yych = *++YYCURSOR;
	goto yy66;
yy66:
#line 416
	{ RETURN(s,T_LYR_CONT); }
yy67:	yych = *++YYCURSOR;
	goto yy68;
yy68:
#line 418
	{ RETURN(s,T_LYR_BAR); }
yy69:	yych = *++YYCURSOR;
	goto yy70;
yy70:
#line 420
	{ if (s->state & S_INFIELD) { 
                         s->nextstate=S_TUNE;
                         RETURN(s,T_NONE);
                       }
                       RETURN(s,T_UNKNOWN);
                     }
yy71:	yych = *++YYCURSOR;
	goto yy77;
yy72:
#line 427
	{ RETURN(s,T_CONTINUE); }
yy73:	yych = *++YYCURSOR;
	goto yy74;
yy74:
#line 429
	{ return -1; }
yy75:	yych = *++YYCURSOR;
	goto yy60;
yy76:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy77;
yy77:	if(yych == '\n')	goto yy76;
	if(yych == '\r')	goto yy76;
	goto yy72;
yy78:	yyaccept = 0;
	YYMARKER = ++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy79;
yy79:	if(yych <= '>'){
		if(yych <= ')'){
			if(yych == '!')	goto yy78;
			if(yych <= '&')	goto yy58;
			goto yy78;
		} else {
			if(yych <= ','){
				if(yych <= '+')	goto yy58;
				goto yy78;
			} else {
				if(yych <= '-')	goto yy80;
				if(yych <= '.')	goto yy78;
				goto yy58;
			}
		}
	} else {
		if(yych <= '\\'){
			if(yych <= '@'){
				if(yych <= '?')	goto yy78;
				goto yy58;
			} else {
				if(yych <= 'Z')	goto yy78;
				if(yych <= '[')	goto yy58;
				goto yy81;
			}
		} else {
			if(yych <= 'z'){
				if(yych <= '`')	goto yy58;
				goto yy78;
			} else {
				if(yych == '~')	goto yy78;
				goto yy58;
			}
		}
	}
yy80:	yych = *++YYCURSOR;
	goto yy58;
yy81:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych <= ' ')	goto yy52;
	if(yych <= '\177')	goto yy78;
	goto yy52;
yy82:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy83;
yy83:	if(yych == '\t')	goto yy82;
	if(yych == ' ')	goto yy82;
	goto yy56;
}
#line 433

  
}

static int abcNT_FIELD_s(abcScanner *s)
{
  YYCTYPE *cursor, *limit, *marker;
  
  cursor = s->cursor;
  limit  = s->limit;
  marker = s->marker;

  STATE(symbol) {
    {
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy84;
yy85:	++YYCURSOR;
yy84:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych <= 'G'){
		if(yych <= '\037'){
			if(yych <= '\b'){
				if(yych <= '\000')	goto yy86;
				if(yych <= '\001')	goto yy87;
				if(yych <= '\002')	goto yy104;
				goto yy108;
			} else {
				if(yych <= '\n'){
					if(yych <= '\t')	goto yy89;
					goto yy106;
				} else {
					if(yych == '\r')	goto yy106;
					goto yy108;
				}
			}
		} else {
			if(yych <= ')'){
				if(yych <= ' ')	goto yy89;
				if(yych <= '!')	goto yy97;
				if(yych <= '"')	goto yy101;
				goto yy108;
			} else {
				if(yych <= '+'){
					if(yych <= '*')	goto yy99;
					goto yy95;
				} else {
					if(yych == '.')	goto yy93;
					goto yy108;
				}
			}
		}
	} else {
		if(yych <= 'T'){
			if(yych <= 'K'){
				if(yych == 'I')	goto yy108;
				if(yych <= 'J')	goto yy93;
				goto yy108;
			} else {
				if(yych <= 'N'){
					if(yych <= 'M')	goto yy93;
					goto yy108;
				} else {
					if(yych <= 'P')	goto yy93;
					if(yych <= 'R')	goto yy108;
					goto yy93;
				}
			}
		} else {
			if(yych <= 'v'){
				if(yych == ']')	goto yy102;
				if(yych <= 't')	goto yy108;
				goto yy93;
			} else {
				if(yych <= '|'){
					if(yych <= '{')	goto yy108;
					goto yy91;
				} else {
					if(yych == '~')	goto yy93;
					goto yy108;
				}
			}
		}
	}
yy86:	YYCURSOR = YYMARKER;
	switch(yyaccept){
	case 1:	goto yy98;
	case 0:	goto yy96;
	}
yy87:	yych = *++YYCURSOR;
	goto yy88;
yy88:
#line 447
	{ s->cursor++; GOTO(symbol); }
yy89:	yych = *++YYCURSOR;
	goto yy129;
yy90:
#line 449
	{ RETURN(s,T_WSPACE); }
yy91:	yych = *++YYCURSOR;
	goto yy92;
yy92:
#line 451
	{ RETURN(s,T_BAR); }
yy93:	yych = *++YYCURSOR;
	goto yy94;
yy94:
#line 453
	{ RETURN(s,T_DECOR); }
yy95:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '\037'){
		if(yych <= '\002')	goto yy96;
		if(yych != '\t')	goto yy126;
		goto yy96;
	} else {
		if(yych <= ' ')	goto yy96;
		if(yych != '+')	goto yy126;
		goto yy96;
	}
yy96:
#line 476
	{ while (*YYCURSOR > EOL &&
                                    !isspace(*YYCURSOR))
                               YYCURSOR++;
                             RETURN(s,T_UNKNOWN);
                           }
yy97:	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '\t'){
		if(yych <= '\002')	goto yy98;
		if(yych <= '\b')	goto yy123;
		goto yy98;
	} else {
		if(yych <= '\037')	goto yy123;
		if(yych >= '"')	goto yy123;
		goto yy98;
	}
yy98:
#line 463
	{ RETURN(s,T_BREAK); }
yy99:	yych = *++YYCURSOR;
	goto yy100;
yy100:
#line 455
	{ RETURN(s,T_DECOR_BLANK); }
yy101:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '>'){
		if(yych <= ';'){
			if(yych <= '\002')	goto yy96;
			goto yy112;
		} else {
			if(yych == '=')	goto yy112;
			goto yy113;
		}
	} else {
		if(yych <= 'G'){
			if(yych <= '?')	goto yy112;
			if(yych <= '@')	goto yy113;
			goto yy115;
		} else {
			if(yych <= ']')	goto yy112;
			if(yych <= '_')	goto yy113;
			goto yy112;
		}
	}
yy102:	yych = *++YYCURSOR;
	goto yy103;
yy103:
#line 465
	{ if (s->state & S_INFIELD) { 
                               s->nextstate=S_TUNE;
                               RETURN(s,T_NONE);
                             }
                             RETURN(s,T_UNKNOWN);
                           }
yy104:	yych = *++YYCURSOR;
	goto yy105;
yy105:
#line 472
	{ return -1; }
yy106:	yych = *++YYCURSOR;
	goto yy110;
yy107:
#line 474
	{ RETURN(s,T_CONTINUE); }
yy108:	yych = *++YYCURSOR;
	goto yy96;
yy109:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy110;
yy110:	if(yych == '\n')	goto yy109;
	if(yych == '\r')	goto yy109;
	goto yy107;
yy111:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy112;
yy112:	if(yych <= '\002')	goto yy86;
	if(yych == '"')	goto yy117;
	goto yy111;
yy113:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy114;
yy114:	if(yych <= '\002')	goto yy86;
	if(yych == '"')	goto yy121;
	goto yy113;
yy115:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy116;
yy116:	if(yych <= '\002')	goto yy86;
	if(yych == '"')	goto yy119;
	goto yy115;
yy117:	yych = *++YYCURSOR;
	goto yy118;
yy118:
#line 461
	{ RETURN(s,T_STRING); }
yy119:	yych = *++YYCURSOR;
	goto yy120;
yy120:
#line 457
	{ RETURN(s,T_CHORD); }
yy121:	yych = *++YYCURSOR;
	goto yy122;
yy122:
#line 459
	{ RETURN(s,T_ANNOTATION); }
yy123:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy124;
yy124:	if(yych <= '\t'){
		if(yych <= '\002')	goto yy86;
		if(yych <= '\b')	goto yy123;
		goto yy86;
	} else {
		if(yych <= '\037')	goto yy123;
		if(yych <= ' ')	goto yy86;
		if(yych >= '"')	goto yy123;
		goto yy125;
	}
yy125:	yych = *++YYCURSOR;
	goto yy94;
yy126:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy127;
yy127:	if(yych <= '\037'){
		if(yych <= '\002')	goto yy86;
		if(yych == '\t')	goto yy86;
		goto yy126;
	} else {
		if(yych <= ' ')	goto yy86;
		if(yych == '+')	goto yy125;
		goto yy126;
	}
yy128:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy129;
yy129:	if(yych == '\t')	goto yy128;
	if(yych == ' ')	goto yy128;
	goto yy90;
}
#line 481

  } 
}
/*
    "[" L [:] (any\[\135])* "]"
                         { RETURN(s,T_INFIELD); }
*/

static int abcNT_TUNE(abcScanner *s)
{

  YYCTYPE *cursor, *limit, *marker;
  YYCTYPE *p,*q;
  
  cursor = s->cursor;
  limit  = s->limit;
  marker = s->marker;

  

  STATE(tune) { 
    {
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy130;
yy131:	++YYCURSOR;
yy130:
	if((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	switch(yych){
	case '\000':	goto yy132;
	case '\001':	goto yy133;
	case '\002':	goto yy135;
	case '\t':	case ' ':	goto yy143;
	case '\n':	case '\r':	goto yy141;
	case '!':	goto yy168;
	case '"':	goto yy182;
	case '(':	goto yy149;
	case ')':	goto yy170;
	case '+':	goto yy167;
	case '-':	goto yy176;
	case '.':	goto yy163;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy178;
	case ':':	goto yy165;
	case '<':	goto yy172;
	case '=':	goto yy145;
	case '>':	goto yy174;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':	goto yy151;
	case 'H':	case 'J':	case 'L':
	case 'M':	case 'O':
	case 'P':	case 'S':
	case 'T':	case 'u':
	case 'v':	case '~':	goto yy166;
	case 'Z':	goto yy157;
	case '[':	goto yy139;
	case ']':	goto yy180;
	case '^':	goto yy147;
	case '_':	goto yy148;
	case '`':	goto yy137;
	case 'x':	goto yy155;
	case 'y':	goto yy159;
	case 'z':	goto yy153;
	case '{':	goto yy183;
	case '|':	goto yy161;
	case '}':	goto yy185;
	default:	goto yy187;
	}
yy132:	YYCURSOR = YYMARKER;
	switch(yyaccept){
	case 3:	goto yy150;
	case 0:	goto yy140;
	case 4:	goto yy169;
	case 1:	goto yy142;
	case 2:	goto yy146;
	}
yy133:	yych = *++YYCURSOR;
	goto yy134;
yy134:
#line 504
	{ s->cursor++; GOTO(tune); }
yy135:	yych = *++YYCURSOR;
	goto yy136;
yy136:
#line 506
	{ RETURN(s,T_ENDLINE); }
yy137:	yych = *++YYCURSOR;
	goto yy138;
yy138:
#line 508
	{ RETURN(s,T_BSPACE); }
yy139:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= 'Z'){
		if(yych <= '/'){
			if(yych == '%')	goto yy251;
			goto yy140;
		} else {
			if(yych <= '9')	goto yy202;
			if(yych <= ':')	goto yy214;
			if(yych >= 'A')	goto yy253;
			goto yy140;
		}
	} else {
		if(yych <= '`'){
			if(yych == ']')	goto yy214;
			goto yy140;
		} else {
			if(yych <= 'z')	goto yy253;
			if(yych == '|')	goto yy214;
			goto yy140;
		}
	}
yy140:
#line 556
	{ RETURN(s,T_CHORDSTART); }
yy141:	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '\037'){
		if(yych <= '\n'){
			if(yych <= '\b')	goto yy142;
			if(yych <= '\t')	goto yy246;
			goto yy244;
		} else {
			if(yych == '\r')	goto yy244;
			goto yy142;
		}
	} else {
		if(yych <= 'Z'){
			if(yych <= ' ')	goto yy246;
			if(yych >= 'A')	goto yy248;
			goto yy142;
		} else {
			if(yych <= '`')	goto yy142;
			if(yych <= 'z')	goto yy248;
			goto yy142;
		}
	}
yy142:
#line 573
	{ RETURN(s,T_CONTINUE); }
yy143:	yych = *++YYCURSOR;
	goto yy243;
yy144:
#line 523
	{ RETURN(s,T_WSPACE); }
yy145:	yych = *++YYCURSOR;
	if(yych <= '@')	goto yy146;
	if(yych <= 'G')	goto yy226;
	if(yych <= '`')	goto yy146;
	if(yych <= 'g')	goto yy226;
	goto yy146;
yy146:
#line 575
	{ return -1; }
yy147:	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= 'G'){
		if(yych <= '.')	goto yy146;
		if(yych <= '9')	goto yy240;
		if(yych <= '@')	goto yy146;
		goto yy226;
	} else {
		if(yych <= '^'){
			if(yych <= ']')	goto yy146;
			goto yy237;
		} else {
			if(yych <= '`')	goto yy146;
			if(yych <= 'g')	goto yy226;
			goto yy146;
		}
	}
yy148:	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= 'G'){
		if(yych <= '.')	goto yy146;
		if(yych <= '9')	goto yy240;
		if(yych <= '@')	goto yy146;
		goto yy226;
	} else {
		if(yych <= '_'){
			if(yych <= '^')	goto yy146;
			goto yy237;
		} else {
			if(yych <= '`')	goto yy146;
			if(yych <= 'g')	goto yy226;
			goto yy146;
		}
	}
yy149:	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '9'){
		if(yych <= '+'){
			if(yych == '\'')	goto yy219;
			goto yy150;
		} else {
			if(yych <= ',')	goto yy219;
			if(yych >= '0')	goto yy230;
			goto yy150;
		}
	} else {
		if(yych <= ']'){
			if(yych == '=')	goto yy232;
			goto yy150;
		} else {
			if(yych <= '^')	goto yy233;
			if(yych <= '_')	goto yy234;
			goto yy150;
		}
	}
yy150:
#line 541
	{ RETURN(s,T_OPENSLUR); }
yy151:	yych = *++YYCURSOR;
	goto yy227;
yy152:
#line 525
	{ RETURN(s,T_NOTE); }
yy153:	yych = *++YYCURSOR;
	goto yy225;
yy154:
#line 527
	{ RETURN(s,T_REST); }
yy155:	yych = *++YYCURSOR;
	goto yy223;
yy156:
#line 529
	{ RETURN(s,T_INVREST); }
yy157:	yych = *++YYCURSOR;
	goto yy221;
yy158:
#line 531
	{ RETURN(s,T_MULTIREST); }
yy159:	yych = *++YYCURSOR;
	goto yy160;
yy160:
#line 533
	{ RETURN(s,T_SPACER); }
yy161:	yych = *++YYCURSOR;
	goto yy215;
yy162:
#line 535
	{ RETURN(s,T_BAR); }
yy163:	yych = *++YYCURSOR;
	if(yych <= ','){
		if(yych == '(')	goto yy217;
		goto yy164;
	} else {
		if(yych <= '-')	goto yy216;
		if(yych == '|')	goto yy218;
		goto yy164;
	}
yy164:
#line 537
	{ RETURN(s,T_DECOR); }
yy165:	yych = *++YYCURSOR;
	if(yych <= '\\'){
		if(yych == ':')	goto yy214;
		goto yy146;
	} else {
		if(yych <= ']')	goto yy214;
		if(yych == '|')	goto yy214;
		goto yy146;
	}
yy166:	yych = *++YYCURSOR;
	goto yy164;
yy167:	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '\037'){
		if(yych <= '\002')	goto yy146;
		if(yych == '\t')	goto yy146;
		goto yy212;
	} else {
		if(yych <= ' ')	goto yy146;
		if(yych == '+')	goto yy146;
		goto yy212;
	}
yy168:	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '\t'){
		if(yych <= '\002')	goto yy169;
		if(yych <= '\b')	goto yy209;
		goto yy169;
	} else {
		if(yych <= '\037')	goto yy209;
		if(yych >= '"')	goto yy209;
		goto yy169;
	}
yy169:
#line 570
	{ RETURN(s,T_BREAK); }
yy170:	yych = *++YYCURSOR;
	goto yy171;
yy171:
#line 543
	{ RETURN(s,T_CLOSESLUR); }
yy172:	yych = *++YYCURSOR;
	goto yy208;
yy173:
#line 545
	{ RETURN(s,T_DOTRIGHT); }
yy174:	yych = *++YYCURSOR;
	goto yy206;
yy175:
#line 547
	{ RETURN(s,T_DOTLEFT); }
yy176:	yych = *++YYCURSOR;
	if(yych == '\'')	goto yy204;
	if(yych == ',')	goto yy204;
	goto yy177;
yy177:
#line 549
	{ RETURN(s,T_TIE); }
yy178:	yych = *++YYCURSOR;
	goto yy203;
yy179:
#line 554
	{ RETURN(s,T_REPEAT); }
yy180:	yych = *++YYCURSOR;
	goto yy181;
yy181:
#line 558
	{ RETURN(s,T_CHORDEND); }
yy182:	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= '>'){
		if(yych <= ';'){
			if(yych <= '\002')	goto yy146;
			goto yy191;
		} else {
			if(yych == '=')	goto yy191;
			goto yy192;
		}
	} else {
		if(yych <= 'G'){
			if(yych <= '?')	goto yy191;
			if(yych <= '@')	goto yy192;
			goto yy194;
		} else {
			if(yych <= ']')	goto yy191;
			if(yych <= '_')	goto yy192;
			goto yy191;
		}
	}
yy183:	yych = *++YYCURSOR;
	if(yych == '/')	goto yy188;
	goto yy184;
yy184:
#line 567
	{ RETURN(s,T_GRACEAPP); }
yy185:	yych = *++YYCURSOR;
	goto yy186;
yy186:
#line 568
	{ RETURN(s,T_GRACEEND); }
yy187:	yych = *++YYCURSOR;
	goto yy146;
yy188:	yych = *++YYCURSOR;
	goto yy189;
yy189:
#line 566
	{ RETURN(s,T_GRACEACC); }
yy190:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy191;
yy191:	if(yych <= '\002')	goto yy132;
	if(yych == '"')	goto yy196;
	goto yy190;
yy192:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy193;
yy193:	if(yych <= '\002')	goto yy132;
	if(yych == '"')	goto yy200;
	goto yy192;
yy194:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy195;
yy195:	if(yych <= '\002')	goto yy132;
	if(yych == '"')	goto yy198;
	goto yy194;
yy196:	yych = *++YYCURSOR;
	goto yy197;
yy197:
#line 564
	{ RETURN(s,T_STRING); }
yy198:	yych = *++YYCURSOR;
	goto yy199;
yy199:
#line 560
	{ RETURN(s,T_CHORD); }
yy200:	yych = *++YYCURSOR;
	goto yy201;
yy201:
#line 562
	{ RETURN(s,T_ANNOTATION); }
yy202:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy203;
yy203:	if(yych <= '+')	goto yy179;
	if(yych <= '-')	goto yy202;
	if(yych <= '/')	goto yy179;
	if(yych <= '9')	goto yy202;
	goto yy179;
yy204:	yych = *++YYCURSOR;
	goto yy177;
yy205:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy206;
yy206:	if(yych == '>')	goto yy205;
	goto yy175;
yy207:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy208;
yy208:	if(yych == '<')	goto yy207;
	goto yy173;
yy209:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy210;
yy210:	if(yych <= '\t'){
		if(yych <= '\002')	goto yy132;
		if(yych <= '\b')	goto yy209;
		goto yy132;
	} else {
		if(yych <= '\037')	goto yy209;
		if(yych <= ' ')	goto yy132;
		if(yych >= '"')	goto yy209;
		goto yy211;
	}
yy211:	yych = *++YYCURSOR;
	goto yy164;
yy212:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy213;
yy213:	if(yych <= '\037'){
		if(yych <= '\002')	goto yy132;
		if(yych == '\t')	goto yy132;
		goto yy212;
	} else {
		if(yych <= ' ')	goto yy132;
		if(yych == '+')	goto yy211;
		goto yy212;
	}
yy214:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy215;
yy215:	if(yych <= '\\'){
		if(yych == ':')	goto yy214;
		goto yy162;
	} else {
		if(yych <= ']')	goto yy214;
		if(yych == '|')	goto yy214;
		goto yy162;
	}
yy216:	yych = *++YYCURSOR;
	if(yych == '\'')	goto yy204;
	if(yych == ',')	goto yy204;
	goto yy177;
yy217:	yych = *++YYCURSOR;
	if(yych == '\'')	goto yy219;
	if(yych == ',')	goto yy219;
	goto yy150;
yy218:	yych = *++YYCURSOR;
	goto yy162;
yy219:	yych = *++YYCURSOR;
	goto yy150;
yy220:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy221;
yy221:	if(yych <= '/')	goto yy158;
	if(yych <= '9')	goto yy220;
	goto yy158;
yy222:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy223;
yy223:	if(yych <= '.')	goto yy156;
	if(yych <= '9')	goto yy222;
	goto yy156;
yy224:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy225;
yy225:	if(yych <= '.')	goto yy154;
	if(yych <= '9')	goto yy224;
	goto yy154;
yy226:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy227;
yy227:	if(yych <= '+'){
		if(yych == '\'')	goto yy226;
		goto yy152;
	} else {
		if(yych <= ',')	goto yy226;
		if(yych <= '.')	goto yy152;
		if(yych >= ':')	goto yy152;
		goto yy228;
	}
yy228:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy229;
yy229:	if(yych <= '.')	goto yy152;
	if(yych <= '9')	goto yy228;
	goto yy152;
yy230:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if(yych == ':')	goto yy238;
	goto yy231;
yy231:
#line 539
	{ RETURN(s,T_NPLET); }
yy232:	yych = *++YYCURSOR;
	if(yych == ')')	goto yy237;
	goto yy132;
yy233:	yych = *++YYCURSOR;
	if(yych == '^')	goto yy232;
	goto yy236;
yy234:	yych = *++YYCURSOR;
	if(yych == '_')	goto yy232;
	goto yy236;
yy235:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy236;
yy236:	if(yych == ')')	goto yy237;
	if(yych <= '.')	goto yy132;
	if(yych <= '9')	goto yy235;
	goto yy132;
yy237:	yych = *++YYCURSOR;
	if(yych <= '@')	goto yy132;
	if(yych <= 'G')	goto yy226;
	if(yych <= '`')	goto yy132;
	if(yych <= 'g')	goto yy226;
	goto yy132;
yy238:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy239;
yy239:	if(yych <= '/')	goto yy231;
	if(yych <= '9')	goto yy230;
	if(yych <= ':')	goto yy238;
	goto yy231;
yy240:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy241;
yy241:	if(yych <= '@'){
		if(yych <= '.')	goto yy132;
		if(yych <= '9')	goto yy240;
		goto yy132;
	} else {
		if(yych <= 'G')	goto yy226;
		if(yych <= '`')	goto yy132;
		if(yych <= 'g')	goto yy226;
		goto yy132;
	}
yy242:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy243;
yy243:	if(yych == '\t')	goto yy242;
	if(yych == ' ')	goto yy242;
	goto yy144;
yy244:	yyaccept = 1;
	YYMARKER = ++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy245;
yy245:	if(yych <= '\037'){
		if(yych <= '\n'){
			if(yych <= '\b')	goto yy142;
			if(yych >= '\n')	goto yy244;
			goto yy246;
		} else {
			if(yych == '\r')	goto yy244;
			goto yy142;
		}
	} else {
		if(yych <= 'Z'){
			if(yych <= ' ')	goto yy246;
			if(yych <= '@')	goto yy142;
			goto yy248;
		} else {
			if(yych <= '`')	goto yy142;
			if(yych <= 'z')	goto yy248;
			goto yy142;
		}
	}
yy246:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy247;
yy247:	if(yych <= ' '){
		if(yych == '\t')	goto yy246;
		if(yych <= '\037')	goto yy132;
		goto yy246;
	} else {
		if(yych <= 'Z'){
			if(yych <= '@')	goto yy132;
			goto yy248;
		} else {
			if(yych <= '`')	goto yy132;
			if(yych >= '{')	goto yy132;
			goto yy248;
		}
	}
yy248:	yych = *++YYCURSOR;
	if(yych != ':')	goto yy132;
	goto yy249;
yy249:	yych = *++YYCURSOR;
	goto yy250;
yy250:
#line 513
	{ p=s->cursor;
                             q=p+1; skipspace(q);
                             while (*q > '\002')
                               *p++=*q++;
                             *p++=']'; *p++='\n'; *p='\0';
                             YYLIMIT=p;
                             YYCURSOR=s->cursor+2;       
                             s->nextstate = S_INFIELD | *(s->cursor);
                             RETURN(s,T_INFIELD); }
yy251:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy252;
yy252:	if(yych <= '/')	goto yy132;
	if(yych <= '9')	goto yy251;
	if(yych == ']')	goto yy256;
	goto yy132;
yy253:	yych = *++YYCURSOR;
	if(yych != ':')	goto yy132;
	goto yy254;
yy254:	yych = *++YYCURSOR;
	goto yy255;
yy255:
#line 510
	{ s->cursor++;
                             s->nextstate = S_INFIELD | *(s->cursor);
                             RETURN(s,T_INFIELD); }
yy256:	yych = *++YYCURSOR;
	goto yy257;
yy257:
#line 551
	{ RETURN(s,T_DUPMESURE); }
}
#line 576

  }
}


/*
** This is the main function. It recognize a new token in the buffer,
** sets the scanner internals appropriately and returns the length
** of the token.
*/

int ABCAPI abcNextToken(abcScanner *s)
{

  YYCTYPE *cursor, *limit, *marker;
  int res=-1;
  int chk;

  /* Avoid calls past the end of file */  
  if (s->state == S_EOF) return -1;

  /* Reset the character saved if any */
  if (s->lastch) *(s->cursor) = s->lastch;

  /* Change to a new state if required */
  if (s->nextstate != S_NONE) {
    s->state=s->nextstate;
    s->nextstate = S_NONE;
  }

  /* Get a new line */  
  if (m_lineempty(s)) abcGetLine(s);

  /* Line is still empty? Must be the end of file!! */  
  if (m_lineempty(s)) {
    m_eof(s);
    return -1;
  }

  cursor = s->cursor;
  limit  = s->limit;
  marker = s->marker;

  /* Look for lines in the history field (H:) */
  if (s->state == (S_FIELD | 'H'))  res=abcNT_FIELD_H(s);
  if (res >= 0) return res;
  
  /* Check for abcTok valid regardless the state*/
  res=abcNT(s);
  if (res >= 0) return res;

  /* If we are in the "limbo" (before o between
  ** songs) consider any line as simple text.
  */
  if (s->state == S_LIMBO) {
    YYCURSOR=YYLIMIT;
    RETURN(s,T_TEXT);
  }

  if (s->state & S_CFIELD) {
    chk = s->state & 0xFF;
    /* Look for syllables in a lyrics line (w:) */
    if (chk ==  'w')  res=abcNT_FIELD_w(s);
    if (res >= 0) return res;
    
    /* Look for symbols in a symbol line (s:) */
    if ((chk == 's') || (chk == 's'))  res=abcNT_FIELD_s(s);
    if (res >= 0) return res;
  }
  
  /* Return the chars up to "]" as content for the fields */
  if (s->state & S_INFIELD) {
    while (*YYCURSOR && (*YYCURSOR != ']')) {
      YYCURSOR++;
      if (*YYCURSOR == '\\' && YYCURSOR[1]) YYCURSOR++;
    }
    if (*YYCURSOR == ']') {
      *YYCURSOR++='\0';
      s->nextstate=S_TUNE;
    }
    RETURN(s,T_FIELDB);
  }
  /**/
  /* Return the entire line as content for the field but stop
     if a comment is found!
  */
  if (s->state & (S_EXTFIELD | S_FIELD)) {
    int instring=0;
    int infield=1;
    
    while (infield) {
      switch(*YYCURSOR) {
        case '\\': if (YYCURSOR[1]) YYCURSOR += 2; break;
        case '"' : instring ^=1; YYCURSOR++; break;
        case '%' : infield=instring; break;
        default:   YYCURSOR++;
      }
      if (infield) infield = (YYCURSOR < YYLIMIT-1);
    }
    
    RETURN(s,T_FIELDB);
  }

  /* Get notes and such from the tune */  
  if (s->state == S_TUNE) res=abcNT_TUNE(s);

  /* Nothing recognized! Report as "unkonwn" */  
  if (res == -1) {
    YYCURSOR=s->cursor+1;
    RETURN(s,T_UNKNOWN);
  }
  
  return res;
}

/*
** Scanner creation routines
*/

void ABCAPI abcClose(abcScanner *s)
{
   if (m_guarded(s)) {
     if (s->file)   fclose(s->file);
     s->file=NULL;
     m_unguard(s);
     free(s);
   }
}

/*
  The scanner does a single memory allocation. The buffer is split in 
  different areas. Is there any danger of trashing those areas? YES!
  We should be very careful!
                                     
   ___bufsize__     __len(fname)__      
  /            \   /              \     
  +------//-----+-+------//--------+-+
  |             |0|                |0|
  +------//-----+-+------//--------+-+
   line/string         filename         
   to be parsed   
  
   _____________bufsize___________    
  /                               \   
  +---------------//---------------+-+
  |                                |0|
  +---------------//---------------+-+
   line/string     
   to be parsed   
                  
*/

static abcScanner *abcNew(ULONG bufsize)
{
  abcScanner *s=NULL;
  ULONG realsize;

  if (bufsize < MINBUFSIZE) bufsize=MINBUFSIZE;
  if (bufsize > MAXBUFSIZE) bufsize=MAXBUFSIZE;
  
  s=malloc( sizeof(abcScanner) + bufsize+16);
  if (s) {
    m_unguard(s);
    s->bufsize=bufsize;
    memset(s->buffer,0,bufsize+16);
    s->line = 0;
    s->state = S_LIMBO;
    s->nextstate = S_NONE;
    s->token = T_NONE;
    s->file = NULL;
    s->filename=NULL;
    s->tokstr=NULL;
    m_guard(s);
    m_resetbuf(s);
    return (s);
  }
  if (s) free(s);
  return (NULL);
}

abcScanner * ABCAPI abcFileScanner(char *filename,ULONG bufsize)
{
  abcScanner *s=NULL;
  
  if (filename != NULL) {
    s=abcNew(bufsize + strlen(filename)+1);
    if (s) {
      s->file=fopen(filename,"r");
      if (s->file) {
        s->bufsize -= strlen(filename)+1;
        s->filename=s->buffer+s->bufsize+1;
        strcpy(s->filename,filename);
      }
      else {
        abcClose(s);
        s=NULL;
      }
    }
  } 
  return(s);
}

abcScanner * ABCAPI abcStringScanner(char *tune)
{
  abcScanner *s=NULL;
  char *b;
  
  if (tune != NULL) {
    s=abcNew(strlen(tune) + 16 );
    /*printf("+\t[%s]\n",tune);*/
    if (s) {
      b=s->buffer+4;
      s->nextln=b;
      s->limit=s->nextln-1;
      while (*tune) 
        *b++ = *tune++;
      *b = '\0';
      s->line=1;
    }
    /*printf("-\t[%s]\n",s->buffer);
    printf("-\t[%s]\n",s->nextln);*/
  } 
  return(s);
}

static int abcScan(abcScanner *as,abcHandler handler)
{
   if (as) {
    while (as->state != S_EOF) {
      abcNextToken(as);
      switch(abcToken(as)) {
        case T_FIELD: 
        case T_INFIELD: 
        case T_NONE:  break;
        
        default: if (handler) {
                   if (handler(as) > 0)
                     m_eof(as);
                 }
                 else {
                   printf("%s\t\t", abcTokenName(as->token));
                   printf("[%s]\n", as->tokstr);
                 }
      }
    }
    abcClose(as);
    return 0;
  }
  return 1; 
}

int ABCAPI abcScanFile(char *filename,abcHandler handler)
{
  abcScanner *as;
    
  as=abcFileScanner(filename,1024);
  return(abcScan(as,handler));
}


int ABCAPI abcScanString(char *buffer,abcHandler handler)
{
  abcScanner *as;
    
  as=abcStringScanner(buffer);
  return(abcScan(as,handler));
}


const char * ABCAPI abcTokenName(int n)
{
  return abcTokName[((n>T_FIRST && n<T_LAST)?n:T_UNKNOWN)];
}

const char * ABCAPI abcStateName(int s)
{
  static char name[80];
  
  name[0]='\0';
  
  if (s == S_EOF)          return (abcStName[0]);
  else if (s == S_ERROR)   return (abcStName[1]);
  else if (s == S_LIMBO)   return (abcStName[2]);
  else if (s == S_NONE)    return (abcStName[3]);
  else if (s == S_TUNE)    return (abcStName[4]);
  else if (s & S_FIELD)    strcpy(name,abcStName[5]);
  else if (s & S_EXTFIELD) strcpy(name,abcStName[6]);
  else if (s & S_INFIELD)  strcpy(name,abcStName[7]);
  
  if (s & S_CFIELD) {
    char *l=name;
    while (*l) l++;
    sprintf(l,"_%c",s & 0xFF);
  }
  else if (s & S_EXTFIELD) {
    char *l=name;
    while (*l) l++;
    sprintf(l,"_%03X",s & 0x0FFF);
  }
  return(name);
}

int ABCAPI abcToken(abcScanner *s)
{ return(s->token); }

int ABCAPI abcState(abcScanner *s)
{ return(s->state); }

const char * ABCAPI abcString(abcScanner *s)
{ return(s->tokstr); }

const abcPacked ABCAPI abcParsedString(abcScanner *s)
{
  if (s->pack[0]=='\0') abcNparse(s);
  return(s->pack);
}

const char * ABCAPI abcFilename(abcScanner *s)
{ return(s->filename); }

int ABCAPI abcLine(abcScanner *s)
{ return(s->line); }

int ABCAPI abcColumn(abcScanner *s)
{ return(m_column(s)); }


